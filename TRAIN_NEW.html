<!DOCTYPE html>
<html>
<head>
    <title>POLICY TRAINER V3.2 - Continue Training</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            max-width: 1400px;
            margin: 20px auto;
            padding: 20px;
            background: #1e1e1e;
            color: #d4d4d4;
        }
        .container {
            background: #252526;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        h1 { color: #4ec9b0; }
        h2 { color: #569cd6; }
        button {
            background: #0e639c;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
        }
        button:hover { background: #1177bb; }
        button:disabled {
            background: #3c3c3c;
            cursor: not-allowed;
        }
        .info-box {
            background: #2d2d30;
            padding: 15px;
            border-radius: 4px;
            margin: 10px 0;
            border-left: 3px solid #4ec9b0;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin: 20px 0;
        }
        .stat-box {
            background: #2d2d30;
            padding: 15px;
            border-radius: 4px;
            text-align: center;
        }
        .stat-value {
            font-size: 28px;
            font-weight: bold;
            color: #4ec9b0;
        }
        .stat-label {
            font-size: 12px;
            color: #858585;
            margin-top: 5px;
        }
        #log {
            background: #1e1e1e;
            padding: 15px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
            border: 1px solid #3c3c3c;
        }
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #1e1e1e;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #0e639c, #1177bb);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
        }
        input[type="number"], select {
            padding: 8px;
            background: #2d2d30;
            border: 1px solid #3c3c3c;
            color: #d4d4d4;
            border-radius: 4px;
            width: 150px;
        }
    </style>
</head>
<body>
    <h1>ðŸ“š V3.2 - Continue Training Support</h1>

    <div class="container">
        <h2>Load Opening Book</h2>
        <input type="file" id="openingBookFile" accept=".json">
        <div id="bookStatus" style="margin: 10px 0; color: #858585;">No opening book loaded</div>
    </div>

    <div class="container">
        <h2>Load Existing Policy (Optional)</h2>
        <input type="file" id="existingPolicyFile" accept=".json">
        <div id="policyStatus" style="margin: 10px 0; color: #858585;">No existing policy (will create new)</div>
    </div>

    <div class="container">
        <h2>Configuration</h2>

        <label>Games to Train:</label><br>
        <input type="number" id="gamesToTrain" value="200" min="100" max="50000">
        <br><br>

        <label>Minimax Threshold:</label><br>
        <input type="number" id="minimaxThreshold" value="6" min="4" max="10">
        <br><br>

        <label>Update Interval:</label><br>
        <input type="number" id="updateInterval" value="50" min="10" max="1000">
    </div>

    <div class="container">
        <h2>Training Controls</h2>
        <button onclick="startTraining()" id="startBtn" disabled>Start Training</button>
        <button onclick="stopTraining()" id="stopBtn" disabled>Stop Training</button>
        <button onclick="downloadPolicy()" id="downloadBtn" disabled>Download Policy</button>

        <div class="progress-bar" style="margin-top: 20px;">
            <div class="progress-fill" id="progressBar" style="width: 0%">0%</div>
        </div>

        <div class="stats-grid">
            <div class="stat-box">
                <div class="stat-value" id="gamesPlayed">0</div>
                <div class="stat-label">Games Played</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="statesLearned">0</div>
                <div class="stat-label">States Learned</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="minimaxMoves">0</div>
                <div class="stat-label">Minimax Moves</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="openingsUsed">0</div>
                <div class="stat-label">Unique Openings</div>
            </div>
        </div>
    </div>

    <div class="container">
        <h2>Log</h2>
        <div id="log"></div>
    </div>

    <script src="hexuki_game_engine_v2.js"></script>
    <script src="minimax_endgame.js"></script>
    <script>
        let openingBook = null;
        let policy = null;
        let existingPolicy = null;
        let isTraining = false;
        let gamesCompleted = 0;
        let minimaxMovesCount = 0;
        let openingsUsedSet = new Set();

        document.getElementById('openingBookFile').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    openingBook = JSON.parse(event.target.result);
                    document.getElementById('bookStatus').innerHTML =
                        `<span style="color: #4ec9b0;">âœ“ LOADED: ${Object.keys(openingBook.openings).length} openings</span>`;
                    updateStartButton();
                    log(`Opening book loaded: ${Object.keys(openingBook.openings).length} openings`);
                } catch (error) {
                    log(`Error: ${error.message}`);
                }
            };
            reader.readAsText(file);
        });

        document.getElementById('existingPolicyFile').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    existingPolicy = JSON.parse(event.target.result);
                    const games = existingPolicy.totalGamesPlayed.toLocaleString();
                    const states = Object.keys(existingPolicy.database).length.toLocaleString();
                    document.getElementById('policyStatus').innerHTML =
                        `<span style="color: #4ec9b0;">âœ“ LOADED: ${games} games, ${states} states - WILL CONTINUE TRAINING</span>`;
                    log(`Existing policy loaded: ${games} games, ${states} states`);
                    log(`Will continue training from this policy`);
                } catch (error) {
                    log(`Error loading policy: ${error.message}`);
                }
            };
            reader.readAsText(file);
        });

        function updateStartButton() {
            document.getElementById('startBtn').disabled = !openingBook;
        }

        function log(message) {
            const logDiv = document.getElementById('log');
            logDiv.textContent += message + '\n';
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function getStateKey(game) {
            const turn = game.currentPlayer;
            const boardState = game.board.map(hex => {
                if (hex.value === null) return 'null';
                if (hex.owner === 'neutral') return `${hex.value}p0`;
                const playerNum = hex.owner === 'player1' ? 1 : 2;
                return `${hex.value}p${playerNum}`;
            }).join(',');

            const p1Available = game.player1Tiles.sort((a, b) => a - b).join('');
            const p2Available = game.player2Tiles.sort((a, b) => a - b).join('');
            const p1Used = Array.from(game.player1UsedPositions).sort((a, b) => a - b).join('');
            const p2Used = Array.from(game.player2UsedPositions).sort((a, b) => a - b).join('');

            return `${turn}|${boardState}|p1a:${p1Available}|p2a:${p2Available}|p1u:${p1Used}|p2u:${p2Used}`;
        }

        // PROPER Fisher-Yates shuffle
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function choosePolicyMove(game) {
            const stateKey = getStateKey(game);
            let legalMoves = game.getAllValidMoves();

            if (legalMoves.length === 0) return null;

            const stateData = policy.database[stateKey];

            // EPSILON-GREEDY: 20% chance to explore (random move)
            const EXPLORATION_RATE = 0.20;
            if (!stateData || Math.random() < EXPLORATION_RATE) {
                // Explore: SHUFFLE for diversity!
                return shuffle([...legalMoves])[0];
            }

            // Exploit: Find best move by win rate
            let bestMove = null;
            let bestScore = -Infinity;

            for (const move of legalMoves) {
                const moveKey = `t${move.tileValue}h${move.hexId}`;
                const moveData = stateData[moveKey];

                if (moveData && moveData.totalWeight > 0) {
                    const winRate = moveData.wins / moveData.totalWeight;
                    if (winRate > bestScore) {
                        bestScore = winRate;
                        bestMove = move;
                    }
                }
            }

            if (!bestMove) {
                bestMove = shuffle([...legalMoves])[0];
            }

            return bestMove;
        }

        function chooseHybridMove(game, threshold) {
            const emptyCount = game.board.filter(h => h.value === null).length;

            if (emptyCount <= threshold) {
                const solver = new MinimaxEndgameSolver(game);
                const move = solver.findBestMove(false);
                if (move) {
                    minimaxMovesCount++;
                    return { hexId: move.hexId, tileValue: move.tile, source: 'minimax' };
                }
            }

            const move = choosePolicyMove(game);
            return move ? {...move, source: 'policy'} : null;
        }

        function selectWeightedOpening() {
            const openings = [];

            for (const [move, stats] of Object.entries(openingBook.openings)) {
                const wr = stats.wins / stats.games;
                if (wr >= 0.50) {  // Only viable openings
                    openings.push({
                        move: move,
                        tileValue: stats.tile,  // Normalize to tileValue
                        hexId: stats.hexId,
                        weight: wr
                    });
                }
            }

            const totalWeight = openings.reduce((sum, o) => sum + o.weight, 0);
            let random = Math.random() * totalWeight;

            for (const opening of openings) {
                random -= opening.weight;
                if (random <= 0) {
                    return opening;
                }
            }

            return openings[openings.length - 1];
        }

        function playTrainingGame(forcedOpening, threshold) {
            const game = new HexukiGameEngineV2();
            const moveHistory = [];

            game.makeMove(forcedOpening.hexId, forcedOpening.tileValue);
            moveHistory.push({
                player: 1,
                tileValue: forcedOpening.tileValue,
                hexId: forcedOpening.hexId,
                source: 'opening_book'
            });

            let moveCount = 1;
            const maxMoves = 18;

            while (!game.gameEnded && moveCount < maxMoves) {
                const move = chooseHybridMove(game, threshold);
                if (!move) break;

                moveHistory.push({
                    player: game.currentPlayer,
                    tileValue: move.tileValue,
                    hexId: move.hexId,
                    source: move.source || 'policy'
                });

                game.makeMove(move.hexId, move.tileValue);
                moveCount++;
            }

            const scores = game.calculateScores();
            const winner = scores.player1 > scores.player2 ? 1 : scores.player2 > scores.player1 ? 2 : 0;

            return { moveHistory, winner, scores };
        }

        function recordGame(gameResult) {
            const game = new HexukiGameEngineV2();

            for (const moveData of gameResult.moveHistory) {
                const stateKey = getStateKey(game);
                const moveKey = `t${moveData.tileValue}h${moveData.hexId}`;

                if (!policy.database[stateKey]) {
                    policy.database[stateKey] = {};
                }

                if (!policy.database[stateKey][moveKey]) {
                    policy.database[stateKey][moveKey] = {
                        wins: 0,
                        losses: 0,
                        ties: 0,
                        totalWeight: 0,
                        gamesPlayed: 0,
                        lastUpdated: Date.now()
                    };
                }

                const moveStats = policy.database[stateKey][moveKey];
                const currentPlayer = moveData.player;
                const weight = moveData.source === 'minimax' ? 2.0 : 1.0;

                let outcome;
                if (gameResult.winner === 0) {
                    outcome = 'tie';
                } else if (gameResult.winner === currentPlayer) {
                    outcome = 'win';
                } else {
                    outcome = 'loss';
                }

                if (outcome === 'win') {
                    moveStats.wins += weight;
                } else if (outcome === 'loss') {
                    moveStats.losses += weight;
                } else {
                    moveStats.ties += weight;
                }

                moveStats.totalWeight += weight;
                moveStats.gamesPlayed += 1;
                moveStats.lastUpdated = Date.now();

                game.makeMove(moveData.hexId, moveData.tileValue);
            }
        }

        function updateProgress(current, total) {
            const percent = Math.round((current / total) * 100);
            const progressBar = document.getElementById('progressBar');
            progressBar.style.width = percent + '%';
            progressBar.textContent = `${percent}% (${current.toLocaleString()} / ${total.toLocaleString()})`;
        }

        function updateStats() {
            document.getElementById('gamesPlayed').textContent = gamesCompleted.toLocaleString();
            document.getElementById('statesLearned').textContent = Object.keys(policy.database).length.toLocaleString();
            document.getElementById('minimaxMoves').textContent = minimaxMovesCount.toLocaleString();
            document.getElementById('openingsUsed').textContent = openingsUsedSet.size;
        }

        async function startTraining() {
            if (!openingBook) {
                log('Load opening book first!');
                return;
            }

            const gamesToTrain = parseInt(document.getElementById('gamesToTrain').value);
            const threshold = parseInt(document.getElementById('minimaxThreshold').value);
            const updateInterval = parseInt(document.getElementById('updateInterval').value);

            // Use existing policy if loaded, otherwise create new
            if (existingPolicy) {
                policy = existingPolicy;
                gamesCompleted = policy.totalGamesPlayed;
                log(`Continuing from existing policy: ${gamesCompleted} games already trained`);
            } else {
                policy = {
                    version: '3.2',
                    created: new Date().toISOString(),
                    totalGamesPlayed: 0,
                    trainingMethod: 'weighted_opening_book_epsilon_greedy_0.20',
                    database: {}
                };
                gamesCompleted = 0;
                log(`Starting new policy from scratch`);
            }

            minimaxMovesCount = 0;
            openingsUsedSet = new Set();
            isTraining = true;

            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;

            const startingGames = gamesCompleted;
            const targetGames = startingGames + gamesToTrain;

            log('='.repeat(80));
            if (existingPolicy) {
                log(`Continuing Training with Epsilon-Greedy (Îµ=0.20)`);
                log(`Previous: ${startingGames} games, Target: ${targetGames} games (+${gamesToTrain} new)`);
            } else {
                log(`Starting Training with Epsilon-Greedy (Îµ=0.20)`);
                log(`Target: ${gamesToTrain} games`);
            }
            log(`Minimax Threshold: ${threshold}`);
            log('='.repeat(80));

            while (isTraining && gamesCompleted < targetGames) {
                const opening = selectWeightedOpening();
                openingsUsedSet.add(opening.move);

                const result = playTrainingGame(opening, threshold);
                recordGame(result);

                gamesCompleted++;
                policy.totalGamesPlayed = gamesCompleted;

                // DEBUG: Log first 3 games in detail
                if (gamesCompleted <= 3) {
                    log(`  Opening: ${opening.move}, Moves: ${result.moveHistory.length}, Winner: P${result.winner}`);
                }

                if (gamesCompleted % updateInterval === 0 || gamesCompleted === targetGames) {
                    updateStats();
                    updateProgress(gamesCompleted - startingGames, gamesToTrain);
                    log(`Game ${gamesCompleted}: ${Object.keys(policy.database).length} states`);
                }

                // Force delay to ensure different Math.random() seed
                await new Promise(resolve => setTimeout(resolve, 5));
            }

            if (isTraining) {
                log('='.repeat(80));
                log(`COMPLETE! ${gamesCompleted} games`);
                log(`States: ${Object.keys(policy.database).length.toLocaleString()}`);
                log(`States per game: ${(Object.keys(policy.database).length / gamesCompleted).toFixed(1)}`);
                log('='.repeat(80));

                document.getElementById('downloadBtn').disabled = false;
            }

            updateStats();
            isTraining = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
        }

        function stopTraining() {
            isTraining = false;
        }

        function downloadPolicy() {
            if (!policy) return;

            const filename = `hexuki_policy_v3_${policy.totalGamesPlayed}games_${Date.now()}.json`;
            const blob = new Blob([JSON.stringify(policy, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();

            URL.revokeObjectURL(url);
            log(`Downloaded: ${filename}`);
        }

        log('V3.2 TRAINER READY - Epsilon-Greedy (Îµ=0.20) + CONTINUE TRAINING');
        log('1. Load opening book (required)');
        log('2. Load existing policy (optional - to continue training)');
        log('3. Click Start Training');
    </script>
</body>
</html>
