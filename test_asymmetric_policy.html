<!DOCTYPE html>
<html>
<head>
    <title>Test Asymmetric Policy (Weighted Best 5 Openings)</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
            background: #1e1e1e;
            color: #d4d4d4;
        }
        .container {
            background: #252526;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        h1 { color: #4ec9b0; }
        button {
            background: #0e639c;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            border-radius: 4px;
        }
        button:hover { background: #1177bb; }
        #log {
            background: #1e1e1e;
            padding: 15px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            max-height: 500px;
            overflow-y: auto;
            white-space: pre-wrap;
            border: 1px solid #3c3c3c;
        }
        .stat-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin: 20px 0;
        }
        .stat-box {
            background: #2d2d30;
            padding: 15px;
            border-radius: 4px;
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #4ec9b0;
        }
        .stat-label {
            font-size: 12px;
            color: #858585;
            margin-top: 5px;
        }
        .info-box {
            background: #2d2d30;
            padding: 15px;
            border-radius: 4px;
            margin: 10px 0;
            border-left: 3px solid #4ec9b0;
        }
        select, input[type="number"] {
            padding: 8px;
            background: #2d2d30;
            border: 1px solid #3c3c3c;
            color: #d4d4d4;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }
    </style>
</head>
<body>
    <h1>⚔️ Test ASYMMETRIC Policy: Weighted Best 5 Openings</h1>

    <div class="container">
        <div class="info-box">
            <strong>Asymmetric Test Strategy:</strong><br>
            • Opening: Weighted random from top 5 (t2h6, t3h14, t4h7, t1h12, t3h12)<br>
            • Midgame: Asymmetric-trained policy (focused on best openings)<br>
            • Endgame (≤6 empty): Perfect minimax<br><br>
            <strong>This matches the training distribution!</strong>
        </div>
    </div>

    <div class="container">
        <h2>Load Asymmetric Policy</h2>
        <input type="file" id="policyFile" accept=".json">
        <div id="policyStatus" style="margin: 10px 0; color: #858585;">No policy loaded</div>
    </div>

    <div class="container">
        <h2>Configuration</h2>

        <label>Opening Strategy:</label><br>
        <select id="openingMove">
            <option value="weighted_best5">Weighted Best 5 (matches training!)</option>
            <option value="t2h6">t2h6 only (78.0% WR)</option>
            <option value="t3h14">t3h14 only (76.0% WR)</option>
            <option value="t4h7">t4h7 only (72.0% WR)</option>
            <option value="t1h12">t1h12 only (72.0% WR)</option>
            <option value="t3h12">t3h12 only (70.0% WR)</option>
            <option value="random">Random Opening (Baseline)</option>
        </select>
        <br><br>

        <label>Games to Test:</label><br>
        <input type="number" id="gamesToTest" value="100" min="10" max="1000" style="width: 100px;">
        <br><br>

        <label>Minimax Threshold:</label><br>
        <input type="number" id="minimaxThreshold" value="6" min="4" max="10" style="width: 100px;">
        <span style="color: #858585; margin-left: 10px;">← empty positions</span>
    </div>

    <div class="container">
        <h2>Test Controls</h2>
        <button onclick="testComplete()">Test Complete AI vs Random</button>
        <button onclick="clearLog()">Clear Log</button>

        <div class="stat-grid" id="stats" style="margin-top: 20px; display: none;">
            <div class="stat-box">
                <div class="stat-value" id="aiWins">0</div>
                <div class="stat-label">AI Wins</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="randomWins">0</div>
                <div class="stat-label">Random Wins</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="ties">0</div>
                <div class="stat-label">Ties</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="winRate">0%</div>
                <div class="stat-label">Win Rate</div>
            </div>
        </div>
    </div>

    <div class="container">
        <h2>Test Log</h2>
        <div id="log"></div>
    </div>

    <script src="hexuki_game_engine_v2.js"></script>
    <script src="minimax_endgame.js"></script>
    <script>
        let policy = null;

        // Load policy file
        document.getElementById('policyFile').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    policy = JSON.parse(event.target.result);
                    const games = policy.totalGamesPlayed?.toLocaleString() || 'unknown';
                    const states = Object.keys(policy.database).length.toLocaleString();
                    document.getElementById('policyStatus').innerHTML =
                        `<span style="color: #4ec9b0;">✓ Loaded: ${games} games trained, ${states} states</span>`;
                    log(`Policy loaded: ${games} games, ${states} states`);
                } catch (error) {
                    document.getElementById('policyStatus').innerHTML =
                        `<span style="color: #f48771;">✗ Error loading policy</span>`;
                    log(`Error: ${error.message}`);
                }
            };
            reader.readAsText(file);
        });

        function log(message) {
            const logDiv = document.getElementById('log');
            logDiv.textContent += message + '\n';
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function clearLog() {
            document.getElementById('log').textContent = '';
        }

        function parseOpening(openingStr) {
            const match = openingStr.match(/t(\d+)h(\d+)/);
            if (!match) return null;
            return {
                tileValue: parseInt(match[1]),
                hexId: parseInt(match[2])
            };
        }

        // Select from best 5 openings with weighted probability (matches training!)
        function selectWeightedBest5Opening() {
            const bestOpenings = [
                {move: 't2h6', tileValue: 2, hexId: 6, wr: 0.78},    // Best
                {move: 't3h14', tileValue: 3, hexId: 14, wr: 0.76},
                {move: 't4h7', tileValue: 4, hexId: 7, wr: 0.72},
                {move: 't1h12', tileValue: 1, hexId: 12, wr: 0.72},
                {move: 't3h12', tileValue: 3, hexId: 12, wr: 0.70}
            ];

            // Weighted random selection
            const totalWeight = bestOpenings.reduce((sum, o) => sum + o.wr, 0);
            let random = Math.random() * totalWeight;

            for (const opening of bestOpenings) {
                random -= opening.wr;
                if (random <= 0) {
                    return opening;
                }
            }

            return bestOpenings[0]; // Default to best
        }

        function getStateKey(game) {
            const turn = game.currentPlayer;
            const boardState = game.board.map(hex => {
                if (hex.value === null) return 'null';
                if (hex.owner === 'neutral') return `${hex.value}p0`;
                const playerNum = hex.owner === 'player1' ? 1 : 2;
                return `${hex.value}p${playerNum}`;
            }).join(',');

            const p1Available = game.player1Tiles.sort((a, b) => a - b).join('');
            const p2Available = game.player2Tiles.sort((a, b) => a - b).join('');
            const p1Used = Array.from(game.player1UsedPositions).sort((a, b) => a - b).join('');
            const p2Used = Array.from(game.player2UsedPositions).sort((a, b) => a - b).join('');

            return `${turn}|${boardState}|p1a:${p1Available}|p2a:${p2Available}|p1u:${p1Used}|p2u:${p2Used}`;
        }

        function choosePolicyMove(game) {
            if (!policy) {
                // No policy loaded, use random
                const legalMoves = game.getAllValidMoves();
                if (legalMoves.length === 0) return null;
                return legalMoves[Math.floor(Math.random() * legalMoves.length)];
            }

            const stateKey = getStateKey(game);
            const legalMoves = game.getAllValidMoves();

            if (legalMoves.length === 0) return null;

            const stateData = policy.database[stateKey];

            if (!stateData) {
                // State not in policy, use random
                return legalMoves[Math.floor(Math.random() * legalMoves.length)];
            }

            // Find best move by win rate
            let bestMove = null;
            let bestScore = -Infinity;

            for (const move of legalMoves) {
                const moveKey = `t${move.tileValue}h${move.hexId}`;
                const moveData = stateData[moveKey];

                if (moveData && moveData.totalWeight > 0) {
                    const winRate = moveData.wins / moveData.totalWeight;
                    if (winRate > bestScore) {
                        bestScore = winRate;
                        bestMove = move;
                    }
                }
            }

            if (!bestMove) {
                // No good move found, use random
                bestMove = legalMoves[Math.floor(Math.random() * legalMoves.length)];
            }

            return bestMove;
        }

        function chooseCompleteAIMove(game, threshold) {
            const emptyCount = game.board.filter(h => h.value === null).length;

            // Endgame: Use minimax
            if (emptyCount <= threshold) {
                const solver = new MinimaxEndgameSolver(game);
                const move = solver.findBestMove(false);
                if (move) {
                    return { hexId: move.hexId, tileValue: move.tile };
                }
            }

            // Midgame: Use policy (or random if no policy)
            return choosePolicyMove(game);
        }

        function chooseRandomMove(game) {
            const legalMoves = game.getAllValidMoves();
            if (legalMoves.length === 0) return null;
            return legalMoves[Math.floor(Math.random() * legalMoves.length)];
        }

        function playGame(forcedOpening, threshold) {
            const game = new HexukiGameEngineV2();
            let moveCount = 0;
            const maxMoves = 18;

            // Move 1: Forced opening for Player 1
            if (forcedOpening) {
                game.makeMove(forcedOpening.hexId, forcedOpening.tileValue);
                moveCount++;
            }

            // Rest of game
            while (!game.gameEnded && moveCount < maxMoves) {
                let move;

                if (game.currentPlayer === 1) {
                    // Player 1: Complete AI (policy + minimax)
                    move = chooseCompleteAIMove(game, threshold);
                } else {
                    // Player 2: Pure random
                    move = chooseRandomMove(game);
                }

                if (!move) break;

                game.makeMove(move.hexId, move.tileValue);
                moveCount++;
            }

            const scores = game.calculateScores();
            return {
                player1Score: scores.player1,
                player2Score: scores.player2,
                winner: scores.player1 > scores.player2 ? 1 : scores.player2 > scores.player1 ? 2 : 0
            };
        }

        async function testComplete() {
            const openingStr = document.getElementById('openingMove').value;
            const gamesToTest = parseInt(document.getElementById('gamesToTest').value);
            const threshold = parseInt(document.getElementById('minimaxThreshold').value);

            let forcedOpening = null;
            let useWeightedBest5 = false;

            if (openingStr === 'weighted_best5') {
                useWeightedBest5 = true;
            } else if (openingStr !== 'random') {
                forcedOpening = parseOpening(openingStr);
                if (!forcedOpening) {
                    log('Error: Invalid opening format');
                    return;
                }
            }

            const policyStatus = policy ? `with policy (${Object.keys(policy.database).length} states)` : 'without policy (random midgame)';

            log('='.repeat(80));
            log(`Testing: ${openingStr} + Complete AI vs Random`);
            log(`Policy: ${policyStatus}`);
            log(`Games: ${gamesToTest}, Minimax threshold: ${threshold}`);
            log('='.repeat(80));

            let aiWins = 0;
            let randomWins = 0;
            let ties = 0;

            for (let i = 0; i < gamesToTest; i++) {
                // Select opening for this game
                let opening = forcedOpening;
                if (useWeightedBest5) {
                    opening = selectWeightedBest5Opening();
                }

                const result = playGame(opening, threshold);

                if (result.winner === 1) {
                    aiWins++;
                } else if (result.winner === 2) {
                    randomWins++;
                } else {
                    ties++;
                }

                // Update UI every 10 games
                if ((i + 1) % 10 === 0) {
                    updateStats(aiWins, randomWins, ties, i + 1);
                    await new Promise(resolve => setTimeout(resolve, 1));
                }
            }

            updateStats(aiWins, randomWins, ties, gamesToTest);

            const winRate = (aiWins / gamesToTest * 100).toFixed(1);

            log('');
            log('='.repeat(80));
            log(`RESULTS:`);
            log(`  AI Wins: ${aiWins} (${winRate}%)`);
            log(`  Random Wins: ${randomWins} (${(randomWins/gamesToTest*100).toFixed(1)}%)`);
            log(`  Ties: ${ties} (${(ties/gamesToTest*100).toFixed(1)}%)`);
            log('='.repeat(80));

            // Comparison
            if (policy) {
                log('');
                log('Comparison:');
                log('  Without policy (random midgame): ~75-78%');
                log(`  With policy (learned midgame): ${winRate}%`);
                log(`  Improvement: ${(parseFloat(winRate) - 76).toFixed(1)} percentage points`);
            }
        }

        function updateStats(wins, losses, ties, total) {
            document.getElementById('stats').style.display = 'grid';
            document.getElementById('aiWins').textContent = wins;
            document.getElementById('randomWins').textContent = losses;
            document.getElementById('ties').textContent = ties;

            const winRate = (wins / total * 100).toFixed(1);
            document.getElementById('winRate').textContent = winRate + '%';
        }

        log('Complete AI Tester Ready');
        log('');
        log('Without policy: Uses best opening + random midgame + minimax endgame');
        log('With policy: Uses best opening + LEARNED midgame + minimax endgame');
        log('');
        log('Load a policy to see the improvement!');
    </script>
</body>
</html>
