<!DOCTYPE html>
<html>
<head>
    <title>Test Hybrid Policy (Policy + Live Minimax)</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
            background: #1e1e1e;
            color: #d4d4d4;
        }
        .container {
            background: #252526;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        h1 { color: #4ec9b0; }
        button {
            background: #0e639c;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            border-radius: 4px;
        }
        button:hover { background: #1177bb; }
        #log {
            background: #1e1e1e;
            padding: 15px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            max-height: 500px;
            overflow-y: auto;
            white-space: pre-wrap;
            border: 1px solid #3c3c3c;
        }
        .stat-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin: 20px 0;
        }
        .stat-box {
            background: #2d2d30;
            padding: 15px;
            border-radius: 4px;
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #4ec9b0;
        }
        .stat-label {
            font-size: 12px;
            color: #858585;
            margin-top: 5px;
        }
        .info-box {
            background: #2d2d30;
            padding: 15px;
            border-radius: 4px;
            margin: 10px 0;
            border-left: 3px solid #4ec9b0;
        }
    </style>
</head>
<body>
    <h1>ðŸŽ¯ Test Hybrid AI: Policy + Live Minimax</h1>

    <div class="container">
        <div class="info-box">
            <strong>Hybrid Strategy:</strong><br>
            â€¢ Opening/Midgame (&gt;6 empty): Use policy<br>
            â€¢ Endgame (â‰¤6 empty): Use LIVE minimax (perfect play)<br>
            â€¢ This ensures 100% perfect endgames regardless of training coverage
        </div>
    </div>

    <div class="container">
        <h2>Load Policy</h2>
        <input type="file" id="policyFile" accept=".json">
        <div id="policyStatus" style="margin: 10px 0; color: #858585;">No policy loaded</div>
    </div>

    <div class="container">
        <h2>Test Configuration</h2>
        <label>Games to Test:</label>
        <input type="number" id="gamesToTest" value="100" min="10" max="1000" style="padding: 5px; margin: 10px;">
        <br><br>
        <button onclick="testHybridVsRandom()">Hybrid vs Random</button>
        <button onclick="testHybridVsHybrid()">Hybrid vs Hybrid</button>
        <button onclick="clearLog()">Clear Log</button>

        <div class="stat-grid" id="stats" style="margin-top: 20px; display: none;">
            <div class="stat-box">
                <div class="stat-value" id="hybridWins">0</div>
                <div class="stat-label">Hybrid Wins</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="opponentWins">0</div>
                <div class="stat-label">Opponent Wins</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="ties">0</div>
                <div class="stat-label">Ties</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="winRate">0%</div>
                <div class="stat-label">Win Rate</div>
            </div>
        </div>
    </div>

    <div class="container">
        <h2>Test Log</h2>
        <div id="log"></div>
    </div>

    <script src="hexuki_game_engine_v2.js"></script>
    <script src="minimax_endgame.js"></script>
    <script>
        let policy = null;

        // Load policy file
        document.getElementById('policyFile').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    policy = JSON.parse(event.target.result);
                    document.getElementById('policyStatus').innerHTML =
                        `<span style="color: #4ec9b0;">âœ“ Loaded: ${policy.totalGamesPlayed?.toLocaleString() || 'unknown'} games trained</span>`;
                    log(`Policy loaded: ${Object.keys(policy.database).length.toLocaleString()} states`);
                } catch (error) {
                    document.getElementById('policyStatus').innerHTML =
                        `<span style="color: #f48771;">âœ— Error loading policy</span>`;
                    log(`Error: ${error.message}`);
                }
            };
            reader.readAsText(file);
        });

        function log(message) {
            const logDiv = document.getElementById('log');
            logDiv.textContent += message + '\n';
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function clearLog() {
            document.getElementById('log').textContent = '';
        }

        function getStateKey(game) {
            const turn = game.currentPlayer;
            const boardState = game.board.map(hex => {
                if (hex.value === null) return 'null';
                if (hex.owner === 'neutral') return `${hex.value}p0`;
                const playerNum = hex.owner === 'player1' ? 1 : 2;
                return `${hex.value}p${playerNum}`;
            }).join(',');

            const p1Available = game.player1Tiles.sort((a, b) => a - b).join('');
            const p2Available = game.player2Tiles.sort((a, b) => a - b).join('');
            const p1Used = Array.from(game.player1UsedPositions).sort((a, b) => a - b).join('');
            const p2Used = Array.from(game.player2UsedPositions).sort((a, b) => a - b).join('');

            return `${turn}|${boardState}|p1a:${p1Available}|p2a:${p2Available}|p1u:${p1Used}|p2u:${p2Used}`;
        }

        function chooseHybridMove(game) {
            const emptyCount = game.board.filter(h => h.value === null).length;

            // Use minimax for endgame (6 or fewer empty)
            if (emptyCount <= 6) {
                const solver = new MinimaxEndgameSolver(game);
                const move = solver.findBestMove(false); // verbose=false for speed
                if (move) {
                    return { hexId: move.hexId, tileValue: move.tile };
                }
            }

            // Use policy for opening/midgame
            return choosePolicyMove(game);
        }

        function choosePolicyMove(game) {
            const stateKey = getStateKey(game);
            const legalMoves = game.getAllValidMoves();

            if (legalMoves.length === 0) return null;

            const stateData = policy.database[stateKey];

            if (!stateData) {
                // State not in policy, choose random
                const randomMove = legalMoves[Math.floor(Math.random() * legalMoves.length)];
                return randomMove;
            }

            // Find best move by win rate
            let bestMove = null;
            let bestScore = -Infinity;

            for (const move of legalMoves) {
                const moveKey = `t${move.tileValue}h${move.hexId}`;
                const moveData = stateData[moveKey];

                if (moveData && moveData.totalWeight > 0) {
                    const winRate = moveData.wins / moveData.totalWeight;
                    if (winRate > bestScore) {
                        bestScore = winRate;
                        bestMove = move;
                    }
                }
            }

            if (!bestMove) {
                const randomMove = legalMoves[Math.floor(Math.random() * legalMoves.length)];
                bestMove = randomMove;
            }

            return bestMove;
        }

        function chooseRandomMove(game) {
            const legalMoves = game.getAllValidMoves();
            if (legalMoves.length === 0) return null;
            return legalMoves[Math.floor(Math.random() * legalMoves.length)];
        }

        async function testHybridVsRandom() {
            if (!policy) {
                log('Please load a policy first!');
                return;
            }

            const gamesToTest = parseInt(document.getElementById('gamesToTest').value);

            log('='.repeat(80));
            log(`Testing Hybrid (Policy+Minimax) vs Random: ${gamesToTest} games`);
            log('='.repeat(80));

            let hybridWins = 0;
            let randomWins = 0;
            let ties = 0;

            for (let gameNum = 0; gameNum < gamesToTest; gameNum++) {
                const game = new HexukiGameEngineV2();
                let moveCount = 0;
                const maxMoves = 18;

                while (!game.gameEnded && moveCount < maxMoves) {
                    let move;

                    if (game.currentPlayer === 1) {
                        // Player 1 uses hybrid (policy + minimax)
                        move = chooseHybridMove(game);
                    } else {
                        // Player 2 plays random
                        move = chooseRandomMove(game);
                    }

                    if (!move) break;

                    game.makeMove(move.hexId, move.tileValue);
                    moveCount++;
                }

                const scores = game.calculateScores();

                if (scores.player1 > scores.player2) {
                    hybridWins++;
                } else if (scores.player2 > scores.player1) {
                    randomWins++;
                } else {
                    ties++;
                }

                // Update UI every 10 games
                if ((gameNum + 1) % 10 === 0) {
                    updateStats(hybridWins, randomWins, ties, gameNum + 1);
                    await new Promise(resolve => setTimeout(resolve, 1));
                }
            }

            updateStats(hybridWins, randomWins, ties, gamesToTest);

            log('');
            log('='.repeat(80));
            log(`RESULTS: Hybrid vs Random`);
            log(`  Hybrid Wins: ${hybridWins} (${(hybridWins/gamesToTest*100).toFixed(1)}%)`);
            log(`  Random Wins: ${randomWins} (${(randomWins/gamesToTest*100).toFixed(1)}%)`);
            log(`  Ties: ${ties} (${(ties/gamesToTest*100).toFixed(1)}%)`);
            log('='.repeat(80));
        }

        async function testHybridVsHybrid() {
            if (!policy) {
                log('Please load a policy first!');
                return;
            }

            const gamesToTest = parseInt(document.getElementById('gamesToTest').value);

            log('='.repeat(80));
            log(`Testing Hybrid vs Hybrid: ${gamesToTest} games`);
            log('='.repeat(80));

            let player1Wins = 0;
            let player2Wins = 0;
            let ties = 0;

            for (let gameNum = 0; gameNum < gamesToTest; gameNum++) {
                const game = new HexukiGameEngineV2();
                let moveCount = 0;
                const maxMoves = 18;

                while (!game.gameEnded && moveCount < maxMoves) {
                    // Both players use hybrid
                    const move = chooseHybridMove(game);

                    if (!move) break;

                    game.makeMove(move.hexId, move.tileValue);
                    moveCount++;
                }

                const scores = game.calculateScores();

                if (scores.player1 > scores.player2) {
                    player1Wins++;
                } else if (scores.player2 > scores.player1) {
                    player2Wins++;
                } else {
                    ties++;
                }

                // Update UI every 10 games
                if ((gameNum + 1) % 10 === 0) {
                    updateStats(player1Wins, player2Wins, ties, gameNum + 1);
                    await new Promise(resolve => setTimeout(resolve, 1));
                }
            }

            updateStats(player1Wins, player2Wins, ties, gamesToTest);

            log('');
            log('='.repeat(80));
            log(`RESULTS: Hybrid vs Hybrid`);
            log(`  Player 1 Wins: ${player1Wins} (${(player1Wins/gamesToTest*100).toFixed(1)}%)`);
            log(`  Player 2 Wins: ${player2Wins} (${(player2Wins/gamesToTest*100).toFixed(1)}%)`);
            log(`  Ties: ${ties} (${(ties/gamesToTest*100).toFixed(1)}%)`);
            log('='.repeat(80));
        }

        function updateStats(wins, losses, ties, total) {
            document.getElementById('stats').style.display = 'grid';
            document.getElementById('hybridWins').textContent = wins;
            document.getElementById('opponentWins').textContent = losses;
            document.getElementById('ties').textContent = ties;

            const winRate = (wins / total * 100).toFixed(1);
            document.getElementById('winRate').textContent = winRate + '%';
        }

        log('Hybrid AI tester ready');
        log('Load a policy file and test with live minimax endgames!');
    </script>
</body>
</html>
